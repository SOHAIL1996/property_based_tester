{"status": "broken", "description": "Activating the pick action test and checking whether it was successful.\n        ", "labels": [{"name": "parentSuite", "value": "tests"}, {"name": "suite", "value": "complex_test"}, {"name": "subSuite", "value": "TestComplexScenario"}, {"name": "host", "value": "Hyper-Dock"}, {"name": "thread", "value": "28591-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython2"}, {"name": "package", "value": "tests.complex_test"}], "stop": 1608337358294, "uuid": "085dffdd-d6c5-4911-8956-7418d87287a7", "historyId": "6df5cbf7c00ce5f14b4c42d69bcd2de9", "name": "test_verification_of_pick_action", "start": 1608337354153, "fullName": "tests.complex_test.TestComplexScenario#test_verification_of_pick_action", "statusDetails": {"message": "ServiceException: service [/get_grasp_pattern] responded with an error:", "trace": "self = <tests.complex_test.TestComplexScenario instance at 0x7fa9a3aac7a0>\n\n    def test_verification_of_pick_action(self):\n        \"\"\"Activating the pick action test and checking whether it was successful.\n        \"\"\"\n        data_logger('logger/logs/pick_action_start')\n        # Pick from table and place on table\n        result = MoveItPickAndPlace(pick_x = -0.03, pick_y = 0.96 , pick_z = 0.57,\n>                                   place_x = 0.5, place_y = 1.0 , place_z = 0.6)\n\ntests/complex_test.py:173: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/action_client/experimental_pick_place_client.py:37: in MoveItPickAndPlace\n    patterns = get_grasp_pattern([target_point], 2, \"target_hand_frame\", geometry_msgs.msg.Vector3(), [], False)\n/opt/ros/kinetic/lib/python2.7/dist-packages/rospy/impl/tcpros_service.py:435: in __call__\n    return self.call(*args, **kwds)\n/opt/ros/kinetic/lib/python2.7/dist-packages/rospy/impl/tcpros_service.py:515: in call\n    responses = transport.receive_once()\n/opt/ros/kinetic/lib/python2.7/dist-packages/rospy/impl/tcpros_base.py:728: in receive_once\n    p.read_messages(b, msg_queue, sock)\n/opt/ros/kinetic/lib/python2.7/dist-packages/rospy/impl/tcpros_service.py:353: in read_messages\n    self._read_ok_byte(b, sock)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <rospy.impl.tcpros_service.TCPROSServiceClient object at 0x7fa9a2feded0>\nb = <cStringIO.StringO object at 0x7fa9a2d3fca8>\nsock = <socket._socketobject object at 0x7fa9a2c5f210>\n\n    def _read_ok_byte(self, b, sock):\n        \"\"\"\n        Utility for reading the OK-byte/error-message header preceding each message.\n        @param sock: socket connection. Will be read from if OK byte is\n        false and error message needs to be read\n        @type  sock: socket.socket\n        @param b: buffer to read from\n        @type  b: StringIO\n        \"\"\"\n        if b.tell() == 0:\n            return\n        pos = b.tell()\n        b.seek(0)\n        ok = struct.unpack('<B', b.read(1))[0] # read in ok byte\n        b.seek(pos)\n        if not ok:\n            str = self._read_service_error(sock, b)\n    \n            #_read_ok_byte has to reset state of the buffer to\n            #consumed as this exception will bypass rest of\n            #deserialized_messages logic. we currently can't have\n            #multiple requests in flight, so we can keep this simple\n            b.seek(0)\n            b.truncate(0)\n>           raise ServiceException(\"service [%s] responded with an error: %s\"%(self.resolved_name, str))\nE           ServiceException: service [/get_grasp_pattern] responded with an error:\n\n/opt/ros/kinetic/lib/python2.7/dist-packages/rospy/impl/tcpros_service.py:336: ServiceException"}, "attachments": [{"source": "23da78af-b288-4c0a-aa53-fc1cfe1fe40d-attachment.txt", "type": "text/plain", "name": "log"}, {"source": "9e147e9d-63b9-4d01-a351-451faa00f0ba-attachment.txt", "type": "text/plain", "name": "stdout"}, {"source": "8971d957-517b-4a20-9984-76fccbd329af-attachment.txt", "type": "text/plain", "name": "stderr"}]}