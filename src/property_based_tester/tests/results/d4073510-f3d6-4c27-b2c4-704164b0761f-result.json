{"status": "broken", "description": "Activating the pick action test and checking whether it was successful.\n        ", "labels": [{"name": "parentSuite", "value": "tests"}, {"name": "suite", "value": "complex_test"}, {"name": "subSuite", "value": "TestComplexScenario"}, {"name": "host", "value": "Hyper-Dock"}, {"name": "thread", "value": "29460-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython2"}, {"name": "package", "value": "tests.complex_test"}], "stop": 1608337587610, "uuid": "4e8193fa-1e02-4e04-b97d-c75cb21bff0d", "historyId": "6df5cbf7c00ce5f14b4c42d69bcd2de9", "name": "test_verification_of_pick_action", "start": 1608337583236, "fullName": "tests.complex_test.TestComplexScenario#test_verification_of_pick_action", "statusDetails": {"message": "ServiceException: service [/get_grasp_pattern] responded with an error:", "trace": "self = <tests.complex_test.TestComplexScenario instance at 0x7f718134d518>\n\n    def test_verification_of_pick_action(self):\n        \"\"\"Activating the pick action test and checking whether it was successful.\n        \"\"\"\n        data_logger('logger/logs/pick_action_start')\n        # Pick from table and place on table\n        result = MoveItPickAndPlace(pick_x = -0.03, pick_y = 0.96 , pick_z = 0.57,\n>                                   place_x = 0.5, place_y = 1.0 , place_z = 0.6)\n\ntests/complex_test.py:173: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/action_client/experimental_pick_place_client.py:37: in MoveItPickAndPlace\n    patterns = get_grasp_pattern([target_point], 2, \"hand_l_distal_link\", geometry_msgs.msg.Vector3(), [], False)\n/opt/ros/kinetic/lib/python2.7/dist-packages/rospy/impl/tcpros_service.py:435: in __call__\n    return self.call(*args, **kwds)\n/opt/ros/kinetic/lib/python2.7/dist-packages/rospy/impl/tcpros_service.py:515: in call\n    responses = transport.receive_once()\n/opt/ros/kinetic/lib/python2.7/dist-packages/rospy/impl/tcpros_base.py:728: in receive_once\n    p.read_messages(b, msg_queue, sock)\n/opt/ros/kinetic/lib/python2.7/dist-packages/rospy/impl/tcpros_service.py:353: in read_messages\n    self._read_ok_byte(b, sock)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <rospy.impl.tcpros_service.TCPROSServiceClient object at 0x7f7180f4e3d0>\nb = <cStringIO.StringO object at 0x7f7180c65c38>\nsock = <socket._socketobject object at 0x7f7180b88210>\n\n    def _read_ok_byte(self, b, sock):\n        \"\"\"\n        Utility for reading the OK-byte/error-message header preceding each message.\n        @param sock: socket connection. Will be read from if OK byte is\n        false and error message needs to be read\n        @type  sock: socket.socket\n        @param b: buffer to read from\n        @type  b: StringIO\n        \"\"\"\n        if b.tell() == 0:\n            return\n        pos = b.tell()\n        b.seek(0)\n        ok = struct.unpack('<B', b.read(1))[0] # read in ok byte\n        b.seek(pos)\n        if not ok:\n            str = self._read_service_error(sock, b)\n    \n            #_read_ok_byte has to reset state of the buffer to\n            #consumed as this exception will bypass rest of\n            #deserialized_messages logic. we currently can't have\n            #multiple requests in flight, so we can keep this simple\n            b.seek(0)\n            b.truncate(0)\n>           raise ServiceException(\"service [%s] responded with an error: %s\"%(self.resolved_name, str))\nE           ServiceException: service [/get_grasp_pattern] responded with an error:\n\n/opt/ros/kinetic/lib/python2.7/dist-packages/rospy/impl/tcpros_service.py:336: ServiceException"}, "attachments": [{"source": "20c583b5-1849-4ce4-9296-6be0881a23c5-attachment.txt", "type": "text/plain", "name": "log"}, {"source": "405fee89-d498-4b1a-b608-193597b6c8ff-attachment.txt", "type": "text/plain", "name": "stdout"}, {"source": "0ff04847-022d-4f34-afa9-1ce5dbc64fc4-attachment.txt", "type": "text/plain", "name": "stderr"}]}