{"name": "test_verification_of_navigation", "status": "broken", "statusDetails": {"message": "ConnectionRefusedError: [Errno 111] Connection refused", "trace": "self = <nav_test.TestNavigation object at 0x7f90ea6fbe50>\nrandomizer = <function TestNavigation.randomizer.<locals>._parameters at 0x7f90e9640c10>\n\n    def test_verification_of_navigation(self,randomizer):\n        \"\"\"Defines a scenario for the rest of the tests to run in using coodrinates.\n        \"\"\"\n        coord_x, coord_y, direction = randomizer(-2,2),randomizer(-2,2),randomizer(0,360)\n        destination_coord.append(coord_x)\n        destination_coord.append(coord_y)\n        # data_logger('logger/logs/nav_start')\n>       result = pose_action_client(coord_x, coord_y, direction)\n\nnav_test.py:101: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\naction_client/navigation_client.py:36: in pose_action_client\n    client = actionlib.SimpleActionClient('move_base', MoveBaseAction)\n/opt/ros/noetic/lib/python3/dist-packages/actionlib/simple_action_client.py:55: in __init__\n    self.action_client = ActionClient(ns, ActionSpec)\n/opt/ros/noetic/lib/python3/dist-packages/actionlib/action_client.py:521: in __init__\n    self.pub_queue_size = rospy.get_param('actionlib_client_pub_queue_size', 10)\n/opt/ros/noetic/lib/python3/dist-packages/rospy/client.py:467: in get_param\n    return _param_server[param_name] #MasterProxy does all the magic for us\n/opt/ros/noetic/lib/python3/dist-packages/rospy/msproxy.py:121: in __getitem__\n    code, msg, value = self.target.getParam(rospy.names.get_caller_id(), resolved_key)\n/usr/lib/python3.8/xmlrpc/client.py:1109: in __call__\n    return self.__send(self.__name, args)\n/opt/ros/noetic/lib/python3/dist-packages/rospy/core.py:669: in _ServerProxy__request\n    return xmlrpcclient.ServerProxy._ServerProxy__request(\n/usr/lib/python3.8/xmlrpc/client.py:1450: in __request\n    response = self.__transport.request(\n/usr/lib/python3.8/xmlrpc/client.py:1153: in request\n    return self.single_request(host, handler, request_body, verbose)\n/usr/lib/python3.8/xmlrpc/client.py:1165: in single_request\n    http_conn = self.send_request(host, handler, request_body, verbose)\n/usr/lib/python3.8/xmlrpc/client.py:1278: in send_request\n    self.send_content(connection, request_body)\n/usr/lib/python3.8/xmlrpc/client.py:1308: in send_content\n    connection.endheaders(request_body)\n/usr/lib/python3.8/http/client.py:1251: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\n/usr/lib/python3.8/http/client.py:1011: in _send_output\n    self.send(msg)\n/usr/lib/python3.8/http/client.py:951: in send\n    self.connect()\n/usr/lib/python3.8/http/client.py:922: in connect\n    self.sock = self._create_connection(\n/usr/lib/python3.8/socket.py:808: in create_connection\n    raise err\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\naddress = ('localhost', 11311), timeout = <object object at 0x7f910aa4ba70>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [Errno 111] Connection refused\n\n/usr/lib/python3.8/socket.py:796: ConnectionRefusedError"}, "description": "Defines a scenario for the rest of the tests to run in using coodrinates.\n        ", "start": 1656502214346, "stop": 1656502214347, "uuid": "376b0961-e0c6-4358-a7f0-6a2955a6caad", "historyId": "ba6902015cb9450d2de8d172ac76cf0f", "testCaseId": "807c1e7d37a89f96ae430cc1a14af8cf", "fullName": "src.property_based_tester.tests.nav_test.TestNavigation#test_verification_of_navigation", "labels": [{"name": "tag", "value": "@pytest.mark.usefixtures('set_up')"}, {"name": "parentSuite", "value": "src.property_based_tester.tests"}, {"name": "suite", "value": "nav_test"}, {"name": "subSuite", "value": "TestNavigation"}, {"name": "host", "value": "legion"}, {"name": "thread", "value": "38969-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "src.property_based_tester.tests.nav_test"}]}