{"status": "broken", "description": "Activating the pick action test and checking whether it was successful.\n        ", "labels": [{"name": "parentSuite", "value": "tests"}, {"name": "suite", "value": "complex_test"}, {"name": "subSuite", "value": "TestComplexScenario"}, {"name": "host", "value": "Hyper-Dock"}, {"name": "thread", "value": "28953-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython2"}, {"name": "package", "value": "tests.complex_test"}], "stop": 1608337428252, "uuid": "1df68f87-1672-44fc-888e-9fa19093e685", "historyId": "6df5cbf7c00ce5f14b4c42d69bcd2de9", "name": "test_verification_of_pick_action", "start": 1608337423561, "fullName": "tests.complex_test.TestComplexScenario#test_verification_of_pick_action", "statusDetails": {"message": "ServiceException: service [/get_grasp_pattern] responded with an error:", "trace": "self = <tests.complex_test.TestComplexScenario instance at 0x7f72ebd33d88>\n\n    def test_verification_of_pick_action(self):\n        \"\"\"Activating the pick action test and checking whether it was successful.\n        \"\"\"\n        data_logger('logger/logs/pick_action_start')\n        # Pick from table and place on table\n        result = MoveItPickAndPlace(pick_x = -0.03, pick_y = 0.96 , pick_z = 0.57,\n>                                   place_x = 0.5, place_y = 1.0 , place_z = 0.6)\n\ntests/complex_test.py:173: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/action_client/experimental_pick_place_client.py:37: in MoveItPickAndPlace\n    patterns = get_grasp_pattern([target_point], 2, \"hand_l_distal_link\", geometry_msgs.msg.Vector3(), [], False)\n/opt/ros/kinetic/lib/python2.7/dist-packages/rospy/impl/tcpros_service.py:435: in __call__\n    return self.call(*args, **kwds)\n/opt/ros/kinetic/lib/python2.7/dist-packages/rospy/impl/tcpros_service.py:515: in call\n    responses = transport.receive_once()\n/opt/ros/kinetic/lib/python2.7/dist-packages/rospy/impl/tcpros_base.py:728: in receive_once\n    p.read_messages(b, msg_queue, sock)\n/opt/ros/kinetic/lib/python2.7/dist-packages/rospy/impl/tcpros_service.py:353: in read_messages\n    self._read_ok_byte(b, sock)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <rospy.impl.tcpros_service.TCPROSServiceClient object at 0x7f72eb0d48d0>\nb = <cStringIO.StringO object at 0x7f72eafcaea0>\nsock = <socket._socketobject object at 0x7f72eb272210>\n\n    def _read_ok_byte(self, b, sock):\n        \"\"\"\n        Utility for reading the OK-byte/error-message header preceding each message.\n        @param sock: socket connection. Will be read from if OK byte is\n        false and error message needs to be read\n        @type  sock: socket.socket\n        @param b: buffer to read from\n        @type  b: StringIO\n        \"\"\"\n        if b.tell() == 0:\n            return\n        pos = b.tell()\n        b.seek(0)\n        ok = struct.unpack('<B', b.read(1))[0] # read in ok byte\n        b.seek(pos)\n        if not ok:\n            str = self._read_service_error(sock, b)\n    \n            #_read_ok_byte has to reset state of the buffer to\n            #consumed as this exception will bypass rest of\n            #deserialized_messages logic. we currently can't have\n            #multiple requests in flight, so we can keep this simple\n            b.seek(0)\n            b.truncate(0)\n>           raise ServiceException(\"service [%s] responded with an error: %s\"%(self.resolved_name, str))\nE           ServiceException: service [/get_grasp_pattern] responded with an error:\n\n/opt/ros/kinetic/lib/python2.7/dist-packages/rospy/impl/tcpros_service.py:336: ServiceException"}, "attachments": [{"source": "9e146a78-3424-48ba-b32b-8755eaf878dc-attachment.txt", "type": "text/plain", "name": "log"}, {"source": "6a96be79-c647-49cc-bc21-d0dfa3d5ca20-attachment.txt", "type": "text/plain", "name": "stdout"}, {"source": "5a46fddd-5a42-4fc5-bac0-567ba4bea87a-attachment.txt", "type": "text/plain", "name": "stderr"}]}